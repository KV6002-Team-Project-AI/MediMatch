/*!
 * Built with Duet Design System
 */
import { fetchIconByUrl } from "./icon-utils";
describe("duet-icon/icon-utils", () => {
    afterEach(() => {
        jest.restoreAllMocks();
    });
    describe("fetchIconByUrl", () => {
        const stubFetchResponse = (response) => {
            jest.spyOn(global, "fetch").mockImplementation(() => Promise.resolve({
                ok: response.ok,
                text: () => Promise.resolve(response.text),
            }));
        };
        it("should return svg text when validation passes", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: true,
                text: "<svg></svg>",
            });
            const result = await fetchIconByUrl("valid.svg");
            expect(result).toEqual("<svg></svg>");
        });
        it("should not request the same SVG twice", async () => {
            expect.assertions(3);
            stubFetchResponse({
                ok: true,
                text: "<svg></svg>",
            });
            const result1 = await fetchIconByUrl("double-request.svg");
            const result2 = await fetchIconByUrl("double-request.svg");
            expect(global.fetch).toHaveBeenCalledTimes(1);
            expect(result1).toBe("<svg></svg>");
            expect(result1).toBe(result2);
        });
        it("should strip any non-SVG tags", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: true,
                text: `<div></div><svg></svg>`,
            });
            const result = await fetchIconByUrl("strip-non-svg-tags.svg");
            expect(result).toEqual(`<svg></svg>`);
        });
        it("should return only the first child element", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: true,
                text: `<svg id="first"></svg><svg id="second"></svg>`,
            });
            const result = await fetchIconByUrl("returns-first-element.svg");
            expect(result).toEqual(`<svg id="first"></svg>`);
        });
        it("should throw an error if request failed", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: false,
                text: "",
            });
            await expect(fetchIconByUrl("failed-request.svg")).rejects.toBeInstanceOf(Error);
        });
        it("should fail validation for SVGs with inline event handlers", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: true,
                text: `<svg><path onclick="alert('pwned')" d="" /></svg>`,
            });
            await expect(fetchIconByUrl("inline-event-handler.svg")).rejects.toMatchObject({
                message: "SVG validation failed",
            });
        });
        it("should fail validation for SVGs with script tags", async () => {
            expect.assertions(1);
            stubFetchResponse({
                ok: true,
                text: `<svg><script>alert("pwned")</script><path d="" /></svg>`,
            });
            await expect(fetchIconByUrl("script-tag.svg")).rejects.toMatchObject({
                message: "SVG validation failed",
            });
        });
    });
});
