/*!
 * Built with Duet Design System
 */
import { createPage } from "../../utils/test-utils";
function camelToKebab(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
}
function isChildren(propsOrChildren) {
    return Array.isArray(propsOrChildren) || typeof propsOrChildren === "string";
}
function dom(tag, propsOrChildren, children) {
    if (propsOrChildren == null) {
        propsOrChildren = {};
    }
    if (isChildren(propsOrChildren)) {
        children = propsOrChildren;
        propsOrChildren = {};
    }
    if (children == null) {
        children = "";
    }
    const attrs = Object.entries(propsOrChildren)
        .map(([attr, value]) => `${camelToKebab(attr)}="${value}"`)
        .join(" ");
    children = Array.isArray(children) ? children : [children];
    return `<${tag} ${attrs}>${children.join("")}</${tag}>`;
}
function paragraph(props, children) {
    return dom("duet-paragraph", props, children);
}
function heading(props, children) {
    return dom("duet-heading", props, children);
}
function drawer(props, children) {
    return dom("duet-notification-drawer", props, children);
}
function notification(props, children) {
    return dom("duet-notification", props, children);
}
function appendFocusableElement(page) {
    return page.evaluate(() => {
        const a = document.createElement("a");
        a.href = "#";
        a.innerText = "some focusable element";
        document.body.appendChild(a);
    });
}
function generatePage(options = { theme: "default" }) {
    return createPage(dom("html", { class: `duet-theme-${options.theme}` }, [
        `<link rel="stylesheet" href="https://cdn.duetds.com/api/css/1.4.16/lib/duet.min.css" />`,
        drawer({ label: "Notifications (3)", badge: true, icon: "messaging-notification" }, [
            notification({ date: "today", url: "#", highlight: true }, [
                heading({ level: "h2", visualLevel: "h6", margin: "none" }, "First notification"),
            ]),
            notification({ date: "today", url: "#" }, [
                paragraph({ size: "small", margin: "none" }, "Second notification"),
            ]),
            notification({ date: "today", url: "#" }, [
                heading({ level: "h2", visualLevel: "h6" }, "Third notification"),
                paragraph({ size: "small", margin: "none" }, "Some text which would serve as the body of the notification"),
            ]),
        ]),
    ]));
}
function getFocusedElement(page) {
    return page.evaluateHandle(() => document.activeElement);
}
function getButton(page) {
    return page.find("duet-notification-drawer >>> button[aria-expanded]");
}
function getContent(page) {
    return page.find("duet-notification-drawer >>> .duet-drawer-content");
}
async function openDrawer(page) {
    const button = await getButton(page);
    await button.click();
    await page.waitForChanges();
}
describe("duet-notification-drawer", () => {
    it("should render a notification drawer", async () => {
        const page = await createPage(drawer({ label: "Notifications" }));
        const component = await page.find("duet-notification-drawer");
        expect(component).not.toBeNull();
        expect(component).toHaveClass("hydrated");
    });
    it("closes on click outside", async () => {
        const page = await generatePage();
        await appendFocusableElement(page); // we need another focusable element for the purpose of test
        await openDrawer(page);
        const link = await page.find("a");
        await link.click();
        await page.waitForChanges();
        const button = await getButton(page);
        const content = await getContent(page);
        expect(await content.isVisible()).toBe(false);
        expect(button).toEqualAttribute("aria-expanded", "false");
    });
    it("closes when focus moves outside", async () => {
        const page = await generatePage();
        await appendFocusableElement(page); // we need another focusable element for the purpose of test
        await openDrawer(page);
        const link = await page.find("a");
        await link.focus();
        await page.waitForChanges();
        const button = await getButton(page);
        const content = await getContent(page);
        expect(await content.isVisible()).toBe(false);
        expect(button).toEqualAttribute("aria-expanded", "false");
    });
    describe("keyboard a11y", () => {
        it("can be opened with keyboard", async () => {
            const page = await generatePage();
            let button = await getButton(page);
            let content = await getContent(page);
            expect(button).toEqualAttribute("aria-expanded", "false");
            expect(await content.isVisible()).toBe(false);
            await page.keyboard.press("Tab");
            await page.keyboard.press("Enter");
            await page.waitForChanges();
            button = await getButton(page);
            content = await getContent(page);
            expect(button).toEqualAttribute("aria-expanded", "true");
            expect(await content.isVisible()).toBe(true);
        });
        it("closes on ESC press", async () => {
            const page = await generatePage();
            await openDrawer(page);
            let content = await getContent(page);
            expect(await content.isVisible()).toBe(true);
            await page.keyboard.press("Escape");
            await page.waitForChanges();
            const button = await getButton(page);
            content = await getContent(page);
            expect(button).toEqualAttribute("aria-expanded", "false");
            expect(await content.isVisible()).toBe(false);
        });
        it("allows for tabbing through notifications", async () => {
            const page = await generatePage();
            await page.keyboard.press("Tab");
            await page.keyboard.press("Enter");
            await page.waitForChanges();
            await page.keyboard.press("Tab");
            let focused = await getFocusedElement(page);
            let text = await page.evaluate((element) => element.innerText, focused);
            expect(text).toContain("First notification");
            await page.keyboard.press("Tab");
            focused = await getFocusedElement(page);
            text = await page.evaluate((element) => element.innerText, focused);
            expect(text).toContain("Second notification");
            await page.keyboard.press("Tab");
            focused = await getFocusedElement(page);
            text = await page.evaluate((element) => element.innerText, focused);
            expect(text).toContain("Third notification");
        });
        it("closes once focus moves out of drawer", async () => {
            const page = await generatePage();
            await appendFocusableElement(page); // we need another focusable element for the test
            await page.keyboard.press("Tab");
            await page.keyboard.press("Enter");
            await page.waitForChanges();
            let button = await getButton(page);
            expect(button).toEqualAttribute("aria-expanded", "true");
            await page.keyboard.press("Tab");
            await page.waitForChanges();
            await page.keyboard.press("Tab");
            await page.waitForChanges();
            await page.keyboard.press("Tab");
            await page.waitForChanges();
            await page.keyboard.press("Tab");
            await page.waitForChanges();
            button = await getButton(page);
            const content = await getContent(page);
            expect(button).toEqualAttribute("aria-expanded", "false");
            expect(await content.isVisible()).toBe(false);
        });
    });
});
