/*!
 * Built with Duet Design System
 */
import { computePosition, flip, offset } from "@floating-ui/dom";
import { Build, h, Host } from "@stencil/core";
import { inheritGlobalTheme } from "../../common/themeable-component";
import { isArrowDownKey, isArrowUpKey, isEscapeKey, isTabKey } from "../../utils/keyboard-utils";
import { Teleport } from "../../utils/teleport";
export class DuetPopupMenu {
    constructor() {
        this.updatePlacement = async () => {
            if (!this.controller) {
                return;
            }
            const coordinates = await computePosition(this.controller, this.element, {
                middleware: [offset({ mainAxis: this.mainAxisOffset, crossAxis: this.crossAxisOffset }), flip()],
                placement: this.placement,
                strategy: this.position,
            });
            this.menuY = coordinates.y;
            this.menuX = coordinates.x;
        };
        this.open = false;
        this.menuY = undefined;
        this.menuX = undefined;
        this.accessibleLabel = undefined;
        this.theme = "";
        this.controller = undefined;
        this.placement = "bottom-start";
        this.position = "absolute";
        this.mainAxisOffset = 0;
        this.crossAxisOffset = 0;
    }
    /**
     * Component lifecycle events.
     */
    componentWillLoad() {
        inheritGlobalTheme(this);
        this.teleport = new Teleport(this.element);
    }
    componentDidLoad() {
        if (!Build.isServer) {
            this.updatePlacement();
        }
    }
    /**
     * Component event handling.
     */
    handleKeyUp(evt) {
        if (this.open) {
            // When Esc is pressed the menu should be closed
            if (isEscapeKey(evt)) {
                this.focusController();
                this.hide();
            }
        }
    }
    async handleKeyDown(evt) {
        if (this.open) {
            if (isArrowDownKey(evt)) {
                evt.preventDefault();
                const current = await this.getFocusedItemIndex();
                if (current !== -1) {
                    if (current < this.itemElements.length - 1) {
                        this.itemElements[current + 1].setFocus();
                    }
                    else {
                        this.itemElements[0].setFocus();
                    }
                }
            }
            if (isArrowUpKey(evt)) {
                evt.preventDefault();
                const current = await this.getFocusedItemIndex();
                if (current !== -1) {
                    if (current === 0) {
                        this.itemElements[this.itemElements.length - 1].setFocus();
                    }
                    else {
                        this.itemElements[current - 1].setFocus();
                    }
                }
            }
            if (isTabKey(evt)) {
                evt.preventDefault();
                this.hide();
            }
        }
    }
    handleClick(evt) {
        const isClickOutside = evt.composedPath().every(node => node !== this.element && node !== this.controller);
        if (this.open && isClickOutside) {
            this.hide();
        }
    }
    /**
     * isOpen.
     */
    async isOpen() {
        return this.open;
    }
    /**
     * Show.
     */
    async show() {
        this.open = true;
        this.teleport.go();
        this.itemElements[0].setFocus();
        this.duetToggle.emit({ open: this.open, component: "duet-popup-menu" });
        this.updatePlacement();
    }
    /**
     * Hide.
     */
    async hide() {
        this.open = false;
        this.duetToggle.emit({ open: this.open, component: "duet-popup-menu" });
        this.focusController();
        this.teleport.resume(200);
    }
    /**
     * Toggle.
     */
    async toggle() {
        if (this.open) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    focusController() {
        if (this.controller) {
            if ("setFocus" in this.controller) {
                this.controller.setFocus();
            }
            else {
                this.controller.focus();
            }
        }
    }
    get itemElements() {
        return Array.from(this.element.querySelectorAll(":scope > duet-popup-menu-item"));
    }
    async getFocusedItemIndex() {
        const items = this.itemElements;
        for (let i = 0; i < items.length; i++) {
            if (await items[i].isFocused()) {
                return i;
            }
        }
        return -1;
    }
    render() {
        const positionStyles = {
            top: `${this.menuY}px`,
            left: `${this.menuX}px`,
        };
        return (h(Host, { class: this.position }, h("div", { style: positionStyles, class: { open: this.open, "duet-popup-menu-list": true, "duet-theme-turva": this.theme === "turva" }, role: "menu", "aria-label": this.accessibleLabel }, h("slot", null))));
    }
    static get is() { return "duet-popup-menu"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["duet-popup-menu.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["duet-popup-menu.css"]
        };
    }
    static get properties() {
        return {
            "accessibleLabel": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Adds accessible label for the menu that is only presented for users of assistive technologies.\nA popup menu should always have an accessible label that describes the popup's function."
                },
                "attribute": "accessible-label",
                "reflect": false
            },
            "theme": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "DuetTheme",
                    "resolved": "\"\" | \"default\" | \"turva\"",
                    "references": {
                        "DuetTheme": {
                            "location": "import",
                            "path": "../../common-types",
                            "id": "src/common-types.d.ts::DuetTheme"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Theme."
                },
                "attribute": "theme",
                "reflect": false,
                "defaultValue": "\"\""
            },
            "controller": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "HTMLElement | (HTMLElement & { setFocus(): void })",
                    "resolved": "HTMLElement | HTMLElement & { setFocus(): void; }",
                    "references": {
                        "HTMLElement": {
                            "location": "global",
                            "id": "global::HTMLElement"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Element controlling the opening and closing of the popup menu."
                }
            },
            "placement": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "| \"top\"\n    | \"right\"\n    | \"bottom\"\n    | \"left\"\n    | \"top-start\"\n    | \"top-end\"\n    | \"right-start\"\n    | \"right-end\"\n    | \"bottom-start\"\n    | \"bottom-end\"\n    | \"left-start\"\n    | \"left-end\"",
                    "resolved": "\"bottom\" | \"bottom-end\" | \"bottom-start\" | \"left\" | \"left-end\" | \"left-start\" | \"right\" | \"right-end\" | \"right-start\" | \"top\" | \"top-end\" | \"top-start\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Placement of the popup menu relative to its controller.\nPossible values: \"top\", \"bottom\", \"left\" and \"right\", optionally combined with \"-start\" or \"-end\"."
                },
                "attribute": "placement",
                "reflect": false,
                "defaultValue": "\"bottom-start\""
            },
            "position": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "\"absolute\" | \"fixed\"",
                    "resolved": "\"absolute\" | \"fixed\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Position."
                },
                "attribute": "position",
                "reflect": false,
                "defaultValue": "\"absolute\""
            },
            "mainAxisOffset": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Main axis positioning offset of the popup menu relative to its controller.\nFor \"top\" and \"bottom\" placements main axis is vertical, for \"left\" and \"right\" horizontal."
                },
                "attribute": "main-axis-offset",
                "reflect": false,
                "defaultValue": "0"
            },
            "crossAxisOffset": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Cross axis positioning offset of the popup menu relative to its controller.\nFor \"top\" and \"bottom\" placements cross axis is horizontal, for \"left\" and \"right\" vertical."
                },
                "attribute": "cross-axis-offset",
                "reflect": false,
                "defaultValue": "0"
            }
        };
    }
    static get states() {
        return {
            "open": {},
            "menuY": {},
            "menuX": {}
        };
    }
    static get events() {
        return [{
                "method": "duetToggle",
                "name": "duetToggle",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the popup menu is opened or closed."
                },
                "complexType": {
                    "original": "DuetPopupMenuEvent",
                    "resolved": "{ open: boolean; component: \"duet-popup-menu\"; }",
                    "references": {
                        "DuetPopupMenuEvent": {
                            "location": "local",
                            "path": "/Users/mgibas/workspace/duet/packages/components/src/components/duet-popup-menu/duet-popup-menu.tsx",
                            "id": "src/components/duet-popup-menu/duet-popup-menu.tsx::DuetPopupMenuEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "isOpen": {
                "complexType": {
                    "signature": "() => Promise<boolean>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<boolean>"
                },
                "docs": {
                    "text": "isOpen.",
                    "tags": []
                }
            },
            "show": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Show.",
                    "tags": []
                }
            },
            "hide": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Hide.",
                    "tags": []
                }
            },
            "toggle": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Toggle.",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "element"; }
    static get listeners() {
        return [{
                "name": "keyup",
                "method": "handleKeyUp",
                "target": "window",
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "handleKeyDown",
                "target": "window",
                "capture": false,
                "passive": false
            }, {
                "name": "click",
                "method": "handleClick",
                "target": "window",
                "capture": false,
                "passive": false
            }];
    }
}
