/*!
 * Built with Duet Design System
 */
/**
 * Teleport helps resolving z-index issues of overlapping popup elements.
 * Initiate it in your component's willLoad or didLoad lifecycle hook.
 * When you open the popup, call teleport.go() and move focus to the popup.
 * When you close the popup, call teleport.resume() and move focus to the element that opened the popup.
 * If your popup has closing animation, use the timeout parameter.
 */
export class Teleport {
    constructor(element, target) {
        this.isActive = false;
        this.element = element;
        this.target = target || document.body;
        this.teleportId = `${Math.random()}-${Date.now()}`.substring(2);
    }
    /**
     * @param makeSiblingsInert - make all siblings of the element inert, use only with modals
     */
    go(makeSiblingsInert = false) {
        const skipTeleport = this.element.getAttribute("skip-teleport");
        if (skipTeleport !== null && skipTeleport !== "false") {
            return;
        }
        // React handles teleporting itself with portals
        if (!this.element.dataset.reactPortal) {
            this.stub = document.createElement("template");
            this.element.insertAdjacentElement("afterend", this.stub);
            this.target.appendChild(this.element);
        }
        if (makeSiblingsInert) {
            this._makeSiblingsInert();
        }
        this.deletionObserver = new MutationObserver(this._deletionObserverCallback.bind(this));
        this.deletionObserver.observe(document.documentElement, { childList: true, subtree: true });
        this.isActive = true;
    }
    resume(delay = 0) {
        const skipTeleport = this.element.getAttribute("skip-teleport");
        if (skipTeleport !== null && skipTeleport !== "false") {
            return;
        }
        if (!this.isActive) {
            return;
        }
        this.isActive = false;
        if (delay) {
            setTimeout(this._resume.bind(this), delay);
        }
        else {
            this._resume();
        }
    }
    _resume() {
        if (!this.element.dataset.reactPortal) {
            this.stub.insertAdjacentElement("beforebegin", this.element);
            this.stub.remove();
        }
        this._removeInertFromSiblings();
        this.deletionObserver.disconnect();
    }
    _remove() {
        var _a, _b;
        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        (_b = this.stub) === null || _b === void 0 ? void 0 : _b.remove();
        this._removeInertFromSiblings();
        this.deletionObserver.disconnect();
    }
    _makeSiblingsInert() {
        const siblings = Array.from(this.target.children);
        siblings.forEach(sibling => {
            if (sibling !== this.element) {
                sibling.dataset.duetTeleportId = (sibling.dataset.duetTeleportId || "") + this.teleportId;
                sibling.inert = true;
            }
        });
    }
    _removeInertFromSiblings() {
        const siblings = Array.from(this.target.children);
        siblings.forEach(sibling => {
            var _a;
            if ((_a = sibling.dataset.duetTeleportId) === null || _a === void 0 ? void 0 : _a.includes(this.teleportId)) {
                sibling.dataset.duetTeleportId = sibling.dataset.duetTeleportId.replace(this.teleportId, "");
                if (sibling.dataset.duetTeleportId === "") {
                    delete sibling.dataset.duetTeleportId;
                    sibling.inert = false;
                }
            }
        });
    }
    /**
     * If the teleported element or its component (observed via stub) is removed from DOM, clean up the teleport.
     */
    _deletionObserverCallback(mutationList) {
        mutationList.forEach(mutation => {
            if (Array.from(mutation.removedNodes).includes(this.element) ||
                Array.from(mutation.removedNodes).some(n => n.contains(this.stub))) {
                this._remove();
            }
        });
    }
}
