/*!
 * Built with Duet Design System
 */
import { c as convertHtmlQuotes } from './string-utils-ca039233.js';

const localeLookUpTable = {
    fi: "fi-FI",
    en: "en-GB",
    us: "en-US",
    sv: "sv-SE",
};
const localeMonetarySignifierLookUpTable = {
    fi: "€",
    en: "£",
    us: "$",
    sv: "€",
};
const defLanguageArray = ["fi", "en", "sv"];
const defaultLanguage = "fi";
const getCurrentLanguage = () => {
    return document.documentElement.lang ? document.documentElement.lang.toLowerCase() : defaultLanguage;
};
const isOfTypeLanguage = (keyInput) => {
    return defLanguageArray.includes(keyInput);
};
const checkForLanguage = (languageString = getCurrentLanguage()) => {
    if (isOfTypeLanguage(languageString)) {
        return languageString;
    }
    else {
        return defaultLanguage;
    }
};
/**
 * Returns the current language as a string representation (taken from html lang attribute)
 * If language is not fi|sv|en it will default to "fi"
 * @param {string} lang=fi - "fi" | "sv" | "en"
 * @default {string} "fi"
 */
const getLanguage = (languageString = getCurrentLanguage()) => checkForLanguage(languageString);
/**
 * Returns the current language and locale
 * If language is not fi|sv|en it will default to "fi"
 * special case where lang can be ALSO be "us" in addition to other types - if user decides to override local language
 * @param {string} lang="fi" - "fi" | "sv" | "en" | "us"
 * @default {object} {locale: "fi-FI", money: "€"}
 */
const getLocale = (lang) => {
    const returnObj = {
        locale: localeLookUpTable[lang],
        money: localeMonetarySignifierLookUpTable[lang],
    };
    if (returnObj.locale && returnObj.money) {
        return returnObj;
    }
    throw new Error(`Locale for "${lang}" not found`);
};
/**
 * Takes any json object that is passed and/or htmlencoded and converts it to proper json
 */
const sanitizeString = (string) => {
    const argIsString = typeof string === "string";
    if (argIsString) {
        try {
            return JSON.parse(convertHtmlQuotes(string));
        }
        catch (e) {
            console.log("sanitizeString received a string, that didnt parse to json object", string, e);
        }
    }
    return string;
};
/**
 * Returns the current string / object from a given translation object
 * If language is not fi|sv|en it will default to "fi"
 * special case where lang can be ALSO be "us" in addition to other types - if user decides to override local language
 * @param {object} langObject - {fi: "finnish", sv: "swedish", en: "english"} | string will get JSON.parsed
 * @param {boolean} languageOverride = false - in case you want to override the actual language set in html tag
 * @default {object} {locale: "fi-FI", money: "€"}
 * @returns {(string|Object)} given example contains {fi:"something"} and language===fi this will return "something"
 */
const getLocaleString = (langObject, languageOverride) => {
    const obj = sanitizeString(langObject);
    if (languageOverride) {
        return obj[checkForLanguage(languageOverride)];
    }
    else {
        return obj[getLanguage()];
    }
};
/**
 * Language change observer
 *
 * Change component's language property or state when the html lang attribute changes. Can also change default labeles to new language.
 * For now the <html> element must have the data-duet-lang-observe attribute set to a truthy value for the
 * language change to happen. At a later point this will be done without requiring the data attribute.
 *
 * Usage:
 * Call in component's connectedCallback
 * connectLanguageChangeObserver(this)
 * or
 * connectLanguageChangeObserver(this, [{ prop: "labelProp", defaults: "labelPropDefaults" }])
 *
 * Call in disconnectedCallback
 * disconnectLanguageChangeObserver(this)
 */
/**
 * Component instances that have subscribed to language change.
 */
const languageChangeSubscribers = new Set();
/**
 * Label properties that should be changed when language changes.
 */
const languageChangeTargets = new WeakMap();
const languagaChangeObserverCallback = mutationList => {
    let oldValue = defaultLanguage;
    for (const mutation of mutationList) {
        if (mutation.type === "attributes" && mutation.attributeName === "lang") {
            oldValue = mutation.oldValue;
            break;
        }
    }
    if (document.documentElement.dataset.duetLangObserve) {
        languageChangeSubscribers.forEach((component) => {
            if (component.language) {
                component.language = getLanguage();
            }
            if (languageChangeTargets.has(component)) {
                languageChangeTargets.get(component).forEach(target => {
                    if (component[target.defaults] && component[target.prop] === component[target.defaults][oldValue]) {
                        component[target.prop] = getLocaleString(component[target.defaults]);
                    }
                });
            }
        });
    }
};
{
    const languageChangeObserver = new MutationObserver(languagaChangeObserverCallback);
    languageChangeObserver.observe(document.documentElement, { attributeFilter: ["lang"], attributeOldValue: true });
}
const connectLanguageChangeObserver = (component, targets) => {
    languageChangeSubscribers.add(component);
    if (targets) {
        if (!Array.isArray(targets)) {
            targets = [targets];
        }
        if (targets.some(t => !(t.prop in component) || !(t.defaults in component))) {
            console.error("connectLanguageChangeObserver: component must have target.prop and target.defaults properties");
            targets = targets.filter(t => t.prop in component && t.defaults in component);
        }
        languageChangeTargets.set(component, targets);
    }
};
const disconnectLanguageChangeObserver = (component) => {
    languageChangeSubscribers.delete(component);
    languageChangeTargets.delete(component);
};

export { getLanguage as a, getLocale as b, connectLanguageChangeObserver as c, disconnectLanguageChangeObserver as d, getLocaleString as g, sanitizeString as s };
